// Generated by the C# M2TypesGenerator: modify at your own risk!
// ReSharper disable InconsistentNaming
// ReSharper disable SuggestVarOrType_SimpleTypes
// ReSharper disable SuggestVarOrType_Elsewhere
#pragma warning disable 1591
#nullable enable
namespace Languages;
using LionWeb.Core;
using LionWeb.Core.M2;
using LionWeb.Core.M3;
using LionWeb.Core.Notification;
using LionWeb.Core.Notification.Partition.Emitter;
using LionWeb.Core.Utilities;
using LionWeb.Core.VersionSpecific.V2023_1;
using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;

[LionCoreLanguage(Key = "FindingLanguage", Version = "0.1")]
public partial class FindingLanguage : LanguageBase<IFindingFactory>
{
	public static readonly FindingLanguage Instance = new Lazy<FindingLanguage>(() => new("FindingLanguage")).Value;
	public FindingLanguage(string id) : base(id, LionWebVersions.v2023_1)
	{
		_finding = new(() => new AnnotationBase<FindingLanguage>("Finding", this) { Key = "Finding", Name = "Finding", AnnotatesLazy = new(() => _builtIns.Node), FeaturesLazy = new(() => [Finding_code, Finding_message, Finding_severity]) });
		_finding_code = new(() => new PropertyBase<FindingLanguage>("Finding-code", Finding, this) { Key = "Finding-code", Name = "code", Optional = true, Type = _builtIns.Integer });
		_finding_message = new(() => new PropertyBase<FindingLanguage>("Finding-message", Finding, this) { Key = "Finding-message", Name = "message", Optional = true, Type = _builtIns.String });
		_finding_severity = new(() => new PropertyBase<FindingLanguage>("Finding-severity", Finding, this) { Key = "Finding-severity", Name = "severity", Optional = true, Type = Severity });
		_severity = new(() => new EnumerationBase<FindingLanguage>("Severity", this) { Key = "Severity", Name = "Severity", LiteralsLazy = new(() => [Severity_error, Severity_info, Severity_warning]) });
		_severity_error = new(() => new EnumerationLiteralBase<FindingLanguage>("Severity-error", Severity, this) { Key = "Severity-error", Name = "error" });
		_severity_info = new(() => new EnumerationLiteralBase<FindingLanguage>("Severity-info", Severity, this) { Key = "Severity-info", Name = "info" });
		_severity_warning = new(() => new EnumerationLiteralBase<FindingLanguage>("Severity-warning", Severity, this) { Key = "Severity-warning", Name = "warning" });
		_factory = new FindingFactory(this);
	}

	/// <inheritdoc/>
        public override IReadOnlyList<LanguageEntity> Entities => [Finding, Severity];
	/// <inheritdoc/>
        public override IReadOnlyList<Language> DependsOn => [];

	private const string _key = "FindingLanguage";
	/// <inheritdoc/>
        public override string Key => _key;

	private const string _name = "Finding";
	/// <inheritdoc/>
        public override string Name => _name;

	private const string _version = "0.1";
	/// <inheritdoc/>
        public override string Version => _version;

	private readonly Lazy<Annotation> _finding;
	public Annotation Finding => _finding.Value;

	private readonly Lazy<Property> _finding_code;
	public Property Finding_code => _finding_code.Value;

	private readonly Lazy<Property> _finding_message;
	public Property Finding_message => _finding_message.Value;

	private readonly Lazy<Property> _finding_severity;
	public Property Finding_severity => _finding_severity.Value;

	private readonly Lazy<Enumeration> _severity;
	public Enumeration Severity => _severity.Value;

	private readonly Lazy<EnumerationLiteral> _severity_error;
	public EnumerationLiteral Severity_error => _severity_error.Value;

	private readonly Lazy<EnumerationLiteral> _severity_info;
	public EnumerationLiteral Severity_info => _severity_info.Value;

	private readonly Lazy<EnumerationLiteral> _severity_warning;
	public EnumerationLiteral Severity_warning => _severity_warning.Value;
}

public partial interface IFindingFactory : INodeFactory
{
	public Finding NewFinding(string id);
	public Finding CreateFinding();
}

public class FindingFactory : AbstractBaseNodeFactory, IFindingFactory
{
	private readonly FindingLanguage _language;
	public FindingFactory(FindingLanguage language) : base(language)
	{
		_language = language;
	}

	/// <inheritdoc/>
        public override INode CreateNode(string id, Classifier classifier)
	{
		if (_language.Finding.EqualsIdentity(classifier))
			return NewFinding(id);
		throw new UnsupportedClassifierException(classifier);
	}

	/// <inheritdoc/>
        public override Enum GetEnumerationLiteral(EnumerationLiteral literal)
	{
		if (_language.Severity.EqualsIdentity(literal.GetEnumeration()))
			return EnumValueFor<Severity>(literal);
		throw new UnsupportedEnumerationLiteralException(literal);
	}

	/// <inheritdoc/>
        public override IStructuredDataTypeInstance CreateStructuredDataTypeInstance(StructuredDataType structuredDataType, IFieldValues fieldValues)
	{
		throw new UnsupportedStructuredDataTypeException(structuredDataType);
	}

	public virtual Finding NewFinding(string id) => new(id);
	public virtual Finding CreateFinding() => NewFinding(GetNewId());
}

[LionCoreMetaPointer(Language = typeof(FindingLanguage), Key = "Finding")]
public partial class Finding : AnnotationInstanceBase
{
	private int? _code = null;
	/// <remarks>Optional Property</remarks>
        [LionCoreMetaPointer(Language = typeof(FindingLanguage), Key = "Finding-code")]
	[LionCoreFeature(Kind = LionCoreFeatureKind.Property, Optional = true, Multiple = false)]
	public int? Code { get => _code; set => SetCode(value); }

	/// <remarks>Optional Property</remarks>
        public bool TryGetCode([NotNullWhenAttribute(true)] out int? code)
	{
		code = _code;
		return _code != null;
	}

	/// <remarks>Optional Property</remarks>
        public Finding SetCode(int? value, INotificationId? notificationId = null)
	{
		PropertyNotificationEmitter emitter = new(FindingLanguage.Instance.Finding_code, this, value, _code, notificationId);
		emitter.CollectOldData();
		_code = value;
		emitter.Notify();
		return this;
	}

	private string? _message = null;
	/// <remarks>Optional Property</remarks>
        [LionCoreMetaPointer(Language = typeof(FindingLanguage), Key = "Finding-message")]
	[LionCoreFeature(Kind = LionCoreFeatureKind.Property, Optional = true, Multiple = false)]
	public string? Message { get => _message; set => SetMessage(value); }

	/// <remarks>Optional Property</remarks>
        public bool TryGetMessage([NotNullWhenAttribute(true)] out string? message)
	{
		message = _message;
		return _message != null;
	}

	/// <remarks>Optional Property</remarks>
        public Finding SetMessage(string? value, INotificationId? notificationId = null)
	{
		PropertyNotificationEmitter emitter = new(FindingLanguage.Instance.Finding_message, this, value, _message, notificationId);
		emitter.CollectOldData();
		_message = value;
		emitter.Notify();
		return this;
	}

	private Severity? _severity = null;
	/// <remarks>Optional Property</remarks>
        [LionCoreMetaPointer(Language = typeof(FindingLanguage), Key = "Finding-severity")]
	[LionCoreFeature(Kind = LionCoreFeatureKind.Property, Optional = true, Multiple = false)]
	public Severity? Severity { get => _severity; set => SetSeverity(value); }

	/// <remarks>Optional Property</remarks>
        public bool TryGetSeverity([NotNullWhenAttribute(true)] out Severity? severity)
	{
		severity = _severity;
		return _severity != null;
	}

	/// <remarks>Optional Property</remarks>
        public Finding SetSeverity(Severity? value, INotificationId? notificationId = null)
	{
		PropertyNotificationEmitter emitter = new(FindingLanguage.Instance.Finding_severity, this, value, _severity, notificationId);
		emitter.CollectOldData();
		_severity = value;
		emitter.Notify();
		return this;
	}

	public Finding(string id) : base(id)
	{
	}

	/// <inheritdoc/>
        public override Annotation GetAnnotation() => FindingLanguage.Instance.Finding;
	/// <inheritdoc/>
        protected override bool GetInternal(Feature? feature, out object? result)
	{
		if (base.GetInternal(feature, out result))
			return true;
		if (FindingLanguage.Instance.Finding_code.EqualsIdentity(feature))
		{
			result = Code;
			return true;
		}

		if (FindingLanguage.Instance.Finding_message.EqualsIdentity(feature))
		{
			result = Message;
			return true;
		}

		if (FindingLanguage.Instance.Finding_severity.EqualsIdentity(feature))
		{
			result = Severity;
			return true;
		}

		return false;
	}

	/// <inheritdoc/>
        protected override bool SetInternal(Feature? feature, object? value, INotificationId? notificationId = null)
	{
		if (base.SetInternal(feature, value, notificationId))
			return true;
		if (FindingLanguage.Instance.Finding_code.EqualsIdentity(feature))
		{
			if (value is null or int)
			{
				SetCode((int?)value, notificationId);
				return true;
			}

			throw new InvalidValueException(feature, value);
		}

		if (FindingLanguage.Instance.Finding_message.EqualsIdentity(feature))
		{
			if (value is null or string)
			{
				SetMessage((string?)value, notificationId);
				return true;
			}

			throw new InvalidValueException(feature, value);
		}

		if (FindingLanguage.Instance.Finding_severity.EqualsIdentity(feature))
		{
			if (value is null or Languages.Severity)
			{
				SetSeverity((Languages.Severity?)value, notificationId);
				return true;
			}

			throw new InvalidValueException(feature, value);
		}

		return false;
	}

	/// <inheritdoc/>
        public override IEnumerable<Feature> CollectAllSetFeatures()
	{
		List<Feature> result = base.CollectAllSetFeatures().ToList();
		if (TryGetCode(out _))
			result.Add(FindingLanguage.Instance.Finding_code);
		if (TryGetMessage(out _))
			result.Add(FindingLanguage.Instance.Finding_message);
		if (TryGetSeverity(out _))
			result.Add(FindingLanguage.Instance.Finding_severity);
		return result;
	}
}

[LionCoreMetaPointer(Language = typeof(FindingLanguage), Key = "Severity")]
public enum Severity
{
	[LionCoreMetaPointer(Language = typeof(FindingLanguage), Key = "Severity-error")]
	error,
	[LionCoreMetaPointer(Language = typeof(FindingLanguage), Key = "Severity-info")]
	info,
	[LionCoreMetaPointer(Language = typeof(FindingLanguage), Key = "Severity-warning")]
	warning
}